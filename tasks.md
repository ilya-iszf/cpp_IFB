# Важное замечание: выполняйте задания по стандартам оформления кода в С++. Нечитаемые задания не засчитываются.

# Простые
**S01 (1б)** создать 4 переменных разного типа, продемонстрировать работу четырех арифметических операторов на выбор

**S02 (1б)** Покажите работу операторов деления нацело и определения остатка от деления

**S11 (1б)** Циклически перебрать числа от 0 до 100. Если число делится на 3 вывести его на экран:  `0	3	6	...	99`

**S12 (1б)** Используя другой тип цикла, перебрать числа от 1 до 1000 с шагом 4. Найти сумму всех чисел, которые делятся на 7 без остатка 
```
Sum: 17640  // (0 - 1000)
Sum: 17395  // (1 - 1000)
```
**S21 (1б)** Получить от пользователя два числа А, В (В>A). Пройти циклом от А до В, вывести значение каждого числа умноженного на 3 в файл «output»

**S22 (1б)** Используя цикл прочитать каждое число из файла «output» и вывести на экран в виде: «n. Число», где n - порядковый номер числа в файле


**S31 (1б)**  Создайте текстовый массив с названиями цифр от 0 до 9. Пользователь вводит число и получает на экран его название.

**S32 (1б)** Пользователь вводит строку. Используя указатель на строку, сдвиньте каждую букву в строке на 1 (a → b, b→c …) (каждый символ задается числом) длину строки можно получить функцией `strlen()` из библиотеки `cstring`.

**S41 (1б)** Напишите функцию `squared_sum()`, которая принимает два дробных числа и возвращает квадрат их суммы
```cpp
cout << squared_sum(12, 6) <<"\n"; // 324
cout << squared_sum(12, -6) <<"\n"; // 36
```

**S42 (2б)** Напишите функцию `sort()`, которая принимает массив из 10 чисел и сортирует их по убыванию
```cpp
int a[10] = {1, 8, 3, 6, 5, 4, 9, 2, 8, 12};
sort(a);	// 12 9 8 7 6 5 4 3 2 1
```

**S51 (1б)** Напишите функцию `reverse()`, которая принимает строку и выводит ее на экран в отраженном виде. «Testing» → «gnitseT»

**S52 (1б)** Напишите перегруженную функцию `print()`, которая выводит на отдельной строке значения, передаваемые ей через запятую. Функция может принимать: 1) `int`; (2) `float`; (3) `char`; (4) `int` и `int`; (Таким образом, фактически, нужно написать четыре функции)


**S61 (2б)** Написать класс ведра `Bucket`.
свойства: `volume` (объем в литрах) и `used` (сколько литров уже налито)
методы: `flush()` (опустошить. весь объем становится доступным для использования) и `fill(v)` (наполнить v литрами жидкости). При вызове метода `fill()` выполняется проверка - достаточно ли в ведре незанятого объема. Если достаточно - метод заполняет ведро (меняет свойство `used`) и возвращает 0. Если недостаточно - ведро заполняется настолько, насколько возможно и возвращается разница (тот объем, который не поместился)
```cpp
    // тестовый код
    Bucket test_01(12, 3);
    cout << "1) " << test_01.volume << ", " << test_01.used << "\n"; // 12, 3
    int rest = test_01.fill(14);
    cout << "2) " << test_01.used << ", " << rest << "\n";  // 12, 5
    
    test_01.flush();
    rest = test_01.fill(8);
    cout << "3) " << test_01.used << ", " << rest << "\n";   // 8, 0
```

**S71 (2б)** Напишите класс `CreditCard`. Его свойства: `Number` (`int`, номер из  4 цифр) и `Balance` (`float`, баланс карты); методы: `Put(V)` и `Take(V)` - положить и снять деньги. И то и другое задается при создании объекта: `CreditCard firstCC(1234, 50)` - карта с номером 1234 и балансом в 50 Р. Продемонстрируйте обращение к методу по указателю ( -> ).

**S72 (2б)** Напишите функцию `Transfer(C1, C2, V)`: где C1 и C2 - это экземпляры класса `CreditCard`; V - это сумма. Функция переводит сумму V с карты С1 на карту С2. Баланс карты С1 не может стать отрицательным. Если денег на карте С1 не хватает для перевода, выводится сообщение об ошибке. Если номера карт совпадают, выводится сообщение, что это одна и та же карта и операция не проводится.

**S81 (1б)** Перегрузите унарный оператор инкремента (`++`) для применения к текстовым строкам: его применение смещает все символы в строке на 1 (см. задание 4.2). Таким же образом перегрузите оператор декремента (`--`)

**S82 (1б)** Перегрузите бинарный оператор + для класса CreditCard так, чтобы операция С1 + С2 переносила весь баланс с С2 на С1 (добавляла все сумму с С2 к С1 и обнуляла баланс С2)


# Средние :+1:: 
**M01 (3б)** Используя циклы выведите таблицу Пифагора. Она должна быть отформатирована (используйте символ табуляции).

**М02 (4б)** Функция принимает два параметра: сторона А и число сторон N, и должна вернуть площадь N-угольника со стороной А. 

# Сложные :star: (уникальные):
~~**H01 (5б)** Напишите функцию расчета синуса, используя его представление в виде ряда: $$sin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9! - x^{11}/11! + x^{13}/13! + ... $$ 
Ограничьтесь первыми 10-ю членами ряда. Вычисление должно происходить в цикле. 
Рекомендация: используйте величины, вычисленные на предыдущем шаге.
Сравните результат вашей функции с тем, что дает sin из модуля `math.h`.~~

**H02 (5б)** Напишите класс комплексных чисел `Complex`. При объявлении переменной типа `Complex`, ему передаются действительная r и мнимая i части: `Complex v(4,5)`. Перегрузите операторы сложения, вычитания, умножения и деления согласно правил этих операций для комплексных чисел (см. комплексная арифметика). Продемонстрируйте работу всех операторов.

**H03 (5б)** Функция same_digits(int from, int to)выводит на экран в возрастающем порядке все числа от from до to, в десятичной записи которых есть одинаковые цифры. Возвращает функция количество таких чисел. Если функции передается одно число, предполагается, что счет идет от 0:
```cpp
cout << same_digits(40); 
// 11 22 33 
// Amount: 3
cout << same_digits(200, 250); 
// 200 202 211 212 222 232 233 242 244  
// Amount: 9
```

**H04 (5б)** Напишите класс `Vector` со свойствами: компоненты вдоль X, Y, Z (`x, y, z`), модуль (`modulus`), массив направляющих косинусов (`angles[3]`). Конструктор принимает компоненты, вычисляет и присваивает модуль и направляющие косинусы. Метод .show() выводит на экран все свойства вектора.
Реализуйте (перегрузите) для этого класса операции сложения, вычитания, умножение на число и скалярное умножение.
```cpp
Vector velocity1(3,3,1), velocity2(0,2,0), result;
result = velocity1 + velocity2;
result.show();
// [3, 5, 1]; modulus=5.916; angles: [29.05 , 48.42,  9.68]
```

+2б: Функция `throw_distance(Vector velocity, float mass)` вектор скорости броска и массу брошенного объекта, и возвращает дистанцию, которую преодолеет предмет после броска.

**H05 (5б)** Усейн Болт бежит по кругу длиной 500 м со скоростью V. После первого круга он видит свой результат и решает, что можно бежать на 5% медленнее. Так происходит на каждом круге. Напишите функцию `usain_run(float V, int N)`, которая возвращает скорость спортсмена на N-ом круге и общее время затраченное на такой забег. Покажите сколько кругов он пробежит, если начнет со скоростью 40 км/ч. Сколько кругов он успеет пробежать за то же время, если стартовая скорость составит 35 км/ч?
Представьте результаты в виде таблицы.

**H06 (5б)** Реализуйте класс Message(string text, char symbol), имеющий метод show(), который выводит на экран табличку, включающую сообщение text. Рамка таблицы состоит из символов symbol.
Максимальная ширина таблички составляет 30 символов (т.е. длинный текст необходимо переносить). Перегрузите оператор сложения так, чтобы результатом был объединенный текст исходных таблиц. 
```cpp
	Message welcome("Добро пожаловать", '*');
	welcome.show();
//********************
//* Добро пожаловать *
//********************
	Message again("снова", '=');
	welcome = welcome + again;
	welcome.show();
//**************************
//* Добро пожаловать снова *
//**************************
```

# Очень сложные :fire: (уникальные) 
~~**X01 (10б)** Функция queen_hit() получает два строчных (string) значения - номера шахматных клеток и должна вернуть true, если ферзь, стоя на первой клетке, угрожает второй. В противном случае возвращается false;~~
```cpp
cout << queen_hit("e2", "e4"); // 1
cout << queen_hit("e2", "f4"); // 0
cout << queen_hit("a1", "c3"); // 1
cout << queen_hit("h8", "a1"); // 1
```

~~Eсли введены некорректные значения, функция предупреждает об этом:~~
```cpp
cout << queen_hit("8e", "a1"); // Error, 0
cout << queen_hit("a8", "q1"); // Error, 0
```

~~**X02 (10б)** Реализуйте функцию `solve_square_equation(float a,float b,float c)`, где `a,b,c` - коэффициенты при степенях x: $ax^2 + bx + c = 0$. Функция возвращает корни заданного уравнения или сообщает об их отсутствии в пространстве рациональных чисел.~~

**X03 (10б)** Реализуйте класс товаров `Item`, имеющий свойства `name`, `prise` и метод `bonus(int n)`, возвращающий значение бонуса в размере n процентов от цены.
Магазин Слата начисляет на карту бонусы в размере 3% от суммы покупки. Начисленные бонусы можно использовать для оплаты любой из покупок, но за такую покупку бонусы начисляться не будут.
Задайте следующий набор покупок (как экземпляры класса Item) (название(цена)):
яблоки 200, молоко 120, конфеты 300, масло 500, орехи 1000, колбаса 350, горчица 45, хлеб 50, чай 100, торт 650.
Напишите программу, которая рассчитает и выведет на экран самый выгодный порядок покупки по этому списку (с самой большой оплатой бонусами). Выполните такой рассчет для двух случаев - с остатком бонусов и с полным их использованием
